Документация на проект – Паралелизиран Merge Sort
Проектът е приложение, което извършва паралелизирано сортиране на масив чрез алгоритъма Merge Sort. Състои се от сървър и 2 клиента, които комуникират по следния начин:
•	Всеки от клиентите подава от стандартния вход 2 числа, които са съответно: 
1.	размер на масива;
2.	брой на нишките, които ще обработват паралелно масива по време на алгоритъма;
•	Тези числа се пращат като заявка към сървъра, който при получаване на тази заявка:
1.	създава два еднакви помежду си масива от случайно генерирани цели числа;
2.	сортира единия от тези масиви само с една нишка, като измерва времето, за което се извършва това сортиране;
3.	сортира другия масив паралелно с подадения от клиента брой нишки, отново измервайки времето, за което се извършва работата.
•	Обратно към подалия заявката клиент се изпращат данни за:
1.	числата от генерираните масиви в първоначалния им ред, преди да са се сортирали
2.	резултатът от сортирането с една нишка – времето, за което се е извършило сортирането + числата, подредени в получения в края сортиран вид
3.	резултатът от сортирането с подадения брой нишки – времето, за което се е извършило сортирането + числата, подредени в получения в края сортиран вид
•	Накрая клиентът записва получените данни в подходящ изходен файл, съответно:
1.	Client_1/client1.txt от клиент 1 (Client 1)
2.	Client_2/client2.txt от клиент 2 (Client 2)
Паралелизацията на сортирането работи с помощта на Thread Pool структура и действа по следния начин:
•	В началото започваме с една нишка, която обработва целия масив.
•	После, всеки път когато се стигне до рекурсивните извиквания на MergeSort, всяка нишка подава лявата половина на своя масив за обработване от нова нишка, докато самата тя продължава с дясната му половина.
•	По този начин, на всяко ниво/слой от рекурсията, броят нишки, които го обработват, расте два пъти повече от преди и всяка от тях разглежда относително еднакъв по размер подмасив с този на останалите.
•	Това размножаване на нишки спира до достигането на подадения от клиента брой нишки, или докато се стигне до дъното на рекурсията. По този начин, работата за всяка нишка става горе-долу равномерно разпределена.
Сървърът е реализиран със select() парадигмата – отделен socket (listenerfd) се създава, който слуша за сигнали от новосвързани клиенти и ги добавя в множеството от вече свързаните със сървъра клиенти. След това тяхното съобщение се получава, обработват се данните и след като им се върне като отговор очакваното съобщение, те се премахват от това множество и затварят.
Ако клиентът подаде грешен вход, на него му се изпраща подходящо съобщение и му се дава възможност да го напише отново. Под  неуспешно подаден вход тук се разбира всяка дума (низ), която не може успешно да се преобразува в положително число.
•	(* По начина, по който е реализирано, вход като „abc1023smlk“ ще бъде отказан, докато “1024asdg” ще се смята за успешно подаден и ще се преобразува в числото 1024. Докато това може би не се счита за много коректно поведение, крайното съобщение, което ще бъде подадено към сървъра, ще се състои от две числа, както се и очаква. Това няма да прецака неговото поведение и да го счупи докато го чакат други клиенти*)

